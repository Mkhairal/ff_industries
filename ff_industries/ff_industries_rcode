get_sic_map <- function(num_ports) {

  valid_ports <- c(5, 10, 12, 17, 30, 38, 48, 49)
  if (!num_ports %in% valid_ports) {
    warning("Invalid number of industries requested.")
    return(NULL)
  }

  url <- sprintf(
    "https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/Siccodes%s.zip",
    num_ports
  )

  tmp_zip <- tempfile(fileext = ".zip")
  on.exit({
    if (file.exists(tmp_zip)) unlink(tmp_zip)
  }, add = TRUE)

  status <- tryCatch(
    download.file(url, tmp_zip, mode = "wb", quiet = TRUE),
    error = function(e) 1L
  )

  if (!is.numeric(status) || status != 0L || !file.exists(tmp_zip)) {
    warning("Failed to download file from Ken French's data library.")
    return(NULL)
  }

  zip_list <- unzip(tmp_zip, list = TRUE)
  if (is.null(zip_list) || nrow(zip_list) == 0) stop("Zip file is empty or unreadable.")

  # Prefer .txt if present, else take the first file
  txt_idx <- which(grepl("\\.txt$", zip_list$Name, ignore.case = TRUE))
  target_name <- if (length(txt_idx) >= 1) zip_list$Name[txt_idx[1]] else zip_list$Name[1]

  tmp_dir <- tempfile("sic_zip_")
  dir.create(tmp_dir)
  on.exit({
    if (dir.exists(tmp_dir)) unlink(tmp_dir, recursive = TRUE, force = TRUE)
  }, add = TRUE)

  extracted_path <- unzip(tmp_zip, files = target_name, exdir = tmp_dir, overwrite = TRUE)

  if (length(extracted_path) != 1 || !file.exists(extracted_path)) {
    stop("Failed to extract SIC definition file from zip.")
  }

  # Read the extracted text
  defns <- paste(readLines(extracted_path, warn = FALSE, encoding = "UTF-8"), collapse = "\n")
  defns <- gsub("\r\n", "\n", defns)

  # ---- SAFER split into industry blocks (no one-word assumption) ----
  # Find header lines: start-of-line, digits, whitespace, then non-empty text
  hdr_pat <- "(?m)^\\s*\\d+\\s+[^\\n]+$"
  m <- gregexpr(hdr_pat, defns, perl = TRUE)[[1]]

  if (length(m) == 1 && m[1] == -1) {
    stop("No industry headers found; file format may have changed.")
  }

  starts <- as.integer(m)
  ends <- c(starts[-1] - 1L, nchar(defns))

  inds <- Map(function(s, e) substr(defns, s, e), starts, ends)
  inds <- unlist(inds, use.names = FALSE)

  if (length(inds) != num_ports) {
    stop(sprintf(
      "Parsed %d industries, expected %d. File format may have changed.",
      length(inds), num_ports
    ))
  }

  all_inds <- list()

  for (ind_block in inds) {

    lines <- strsplit(ind_block, "\n", fixed = TRUE)[[1]]
    lines <- lines[nzchar(trimws(lines))]

    if (length(lines) == 0) next

    header <- lines[1]
    sub_lines <- if (length(lines) > 1) lines[-1] else character(0)

    # Header: digits + whitespace + industry name (allow spaces)
    h <- regexec("^\\s*(\\d+)\\s+(.+?)\\s*$", header, perl = TRUE)
    hi <- regmatches(header, h)[[1]]
    if (length(hi) < 3) next

    indid <- as.integer(hi[2])
    indname <- trimws(hi[3])

    if (length(sub_lines) == 0) {
      warning(sprintf('No SIC code ranges provided for industry "%s".', indname))
      next
    }

    # Each SIC range line: "####-#### <optional description>"
    for (ln in sub_lines) {
      r <- regexec("^\\s*(\\d+)\\s*-\\s*(\\d+)\\s*(.*)\\s*$", ln, perl = TRUE)
      ri <- regmatches(ln, r)[[1]]
      if (length(ri) < 4) next

      sic1 <- suppressWarnings(as.integer(ri[2]))
      sic2 <- suppressWarnings(as.integer(ri[3]))
      sub  <- trimws(ri[4])

      if (is.na(sic1) || is.na(sic2) || sic1 > sic2) next

      all_inds[[length(all_inds) + 1]] <- data.frame(
        id   = indid,
        ind  = indname,
        sic1 = sic1,
        sic2 = sic2,
        sub  = sub,
        stringsAsFactors = FALSE
      )
    }
  }

  if (length(all_inds) == 0) {
    warning("No SIC ranges parsed; returning NULL.")
    return(NULL)
  }

  inds_df <- do.call(rbind, all_inds)

  # Build SIC -> (id, ind, sub) as a named list
  inds_dict <- vector("list", length = 0)

  for (i in seq_len(nrow(inds_df))) {
    row <- inds_df[i, ]
    for (sic in seq.int(row$sic1, row$sic2)) {
      inds_dict[[as.character(sic)]] <- list(
        id  = row$id,
        ind = row$ind,
        sub = row$sub
      )
    }
  }

  inds_dict
}
